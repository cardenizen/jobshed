CREATE OR REPLACE VIEW SENSOR_MOD AS
SELECT SM.MODEL,S.* 
FROM MNR.SENSOR S JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID

--DROP SEQUENCE JOBSEQ;
--CREATE SEQUENCE JOBSEQ MINVALUE 1 START WITH 1 INCREMENT BY 1 CACHE 20;
DROP TABLE JOB_SETUP PURGE;
CREATE TABLE JOB_SETUP (
    JOB_NAME                   VARCHAR2(50),
    CRON_EXPR                  VARCHAR2(50),
    PARAMETER_MAP              CLOB  default EMPTY_CLOB(),
--    
    ID NUMBER(19)              PRIMARY KEY NOT NULL,
    VERSION                    NUMBER(19) NOT NULL,
    CREATED_BY                 VARCHAR2(255) NOT NULL,
    DATE_CREATED               TIMESTAMP NOT NULL,
    LAST_UPDATED               TIMESTAMP NOT NULL,
    LAST_UPDATED_BY            VARCHAR2(255) NOT NULL
	)
TABLESPACE MNR_DATA NOLOGGING
   PCTFREE 10
   INITRANS 1
   MAXTRANS 255
  STORAGE (
   INITIAL 65536
   MINEXTENTS 1
   MAXEXTENTS 2147483645
 )
   NOCACHE
;

DROP SEQUENCE JOBSEQ;
CREATE SEQUENCE JOBSEQ MINVALUE 1 START WITH 1 INCREMENT BY 1 CACHE 20;
DROP TABLE JOB_RESULT PURGE;
CREATE TABLE JOB_RESULT (
    ID					 NUMBER(19) PRIMARY KEY,
    JOB_NAME                   VARCHAR2(50) NOT NULL,
    START_TIME                 TIMESTAMP NOT NULL,
    DURATION                   VARCHAR2(200),
    RESULT                     VARCHAR2(4000),
    PARAMETER_MAP              CLOB  default EMPTY_CLOB()
	)
TABLESPACE MNR_DATA NOLOGGING
   PCTFREE 10
   INITRANS 1
   MAXTRANS 255
  STORAGE (
   INITIAL 65536
   MINEXTENTS 1
   MAXEXTENTS 2147483645
 )
   NOCACHE
;

// Groovy Code here

// Implicit variables include:
//     ctx: the Spring application context
//     grailsApplication: the Grails application
//     config: the Grails configuration
//     request: the HTTP request
//     session: the HTTP session

import us.mn.state.dot.mnroad.*

def ds = ctx.getBean("exportDataService")
ds.dpMaterials(jsi.toMap())

import us.mn.state.dot.mnroad.*

def jsi = JobSetup.get(3L)

def cc = new ConfigController()
def tableName = "mnr.mat_samples"
def prefix = "SELECT MNROAD_ID, CELL, STATION, OFFSET, TO_CHAR(SAMPLE_DATE,'yyyy-mm-dd'), MATERIAL_GROUP, CONTAINER_TYPE, STORAGE_LOCATION, COMMENTS, FIELD_ID, CONTACT_PERSON, COURSE, LIFT_NUMBER, DEPTH_CODE, SAMPLE_DEPTH_TOP, SAMPLE_DEPTH_BOTTOM, SAMPLE_TIME, SAMPLE_CURE_TIME, SPEC FROM"
def crit = "WHERE CELL > 0"
def order = "ORDER BY CELL, MNROAD_ID"
cc.batch(tableName,prefix,crit,order)

import us.mn.state.dot.mnroad.*

def jsi = JobSetup.get(3L)
def jobmap = jsi.toMap()
jobmap.each() { outsidemap ->
   if (outsidemap.value instanceof String) {
      println "${outsidemap.key}:  ${outsidemap.value} (${outsidemap.value.class})"
   } else if (outsidemap.value instanceof String[]) {
      println "${outsidemap}:  (${outsidemap.class})"
   } else {
      println "${outsidemap.key}: ${outsidemap.value.size()} entries."
      def insidemap = outsidemap.getValue()
      println insidemap
      insidemap.each() {
         if (it instanceof String) {
            println "${it}"
         } else {
            println "\t${it.key}: ${it.value}"
         }
      }
   }
}
"Done!"

SELECT table_name,
column_id "ordinal_position",
         column_name,
         data_type,
         nullable,
         nvl(data_precision,0) precision,
         COALESCE(data_precision, data_length) length,
         nvl(data_scale,0) scale
    FROM all_tab_columns
   WHERE owner='MNR'
ORDER BY table_name, column_id;

SELECT unique table_name FROM all_tab_columns
WHERE owner='MNR'
order by table_name;

import us.mn.state.dot.mnroad.MrUtils
import groovy.sql.Sql
def dataSource = ctx.dataSource
def sql = Sql.newInstance(dataSource)
def q = """
SELECT ID,CELL
,CELL_END_DATE
,DESIGN_NUMBER
,TO_NUMBER(TO_CHAR(CONSTRUCTION_BEGAN_DATE,'yyyy')) FROM_YEAR
,TO_NUMBER(TO_CHAR(NVL(CELL_END_DATE, ?),'yyyy')) TO_YEAR
FROM (SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) CELL_END_DATE,DESIGN_NUMBER FROM (SELECT ID,CELL_NUMBER CELL,SUBSTR(CLASS,24) CELL_TYPE,(SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=C.ID) CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,DEMOLISHED_DATE,CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1 WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2 WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3 WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4 WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5 ELSE 1 END DESIGN_NUMBER FROM MNR.CELL C))
WHERE CELL <= ? ORDER BY CELL, CONSTRUCTION_BEGAN_DATE
"""
def rows = sql.rows(q.toString(),[MrUtils.endOfYearDate(2010),3]) as List
for (row in rows) {
   [row.FROM_YEAR..row.TO_YEAR].each {
      println "${row.CELL}, ${row.DESIGN_NUMBER}, ${it}"   
   }
}
"${rows.size()} cells found."

import groovy.sql.Sql
import us.mn.state.dot.mnroad.MrUtils

def dataSource = ctx.dataSource
def sql = Sql.newInstance(dataSource)
def q = """
SELECT ID,CELL,DESIGN_NUMBER,CONSTRUCTION_BEGAN_DATE,NVL(CELL_END_DATE,?) CELL_END_DATE,TO_NUMBER(TO_CHAR(CONSTRUCTION_BEGAN_DATE,'yyyy')) FROM_YEAR,TO_NUMBER(TO_CHAR(NVL(CELL_END_DATE, ?),'yyyy')) TO_YEAR
FROM (SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) CELL_END_DATE,DESIGN_NUMBER FROM (SELECT ID,CELL_NUMBER CELL,SUBSTR(CLASS,24) CELL_TYPE,(SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=C.ID) CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,DEMOLISHED_DATE,CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1 WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2 WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3 WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4 WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5 ELSE 1 END DESIGN_NUMBER FROM MNR.CELL C))
WHERE CELL <= ? ORDER BY CELL, CONSTRUCTION_BEGAN_DATE
"""
def eoyts = MrUtils.endOfYearSqlTimestamp(2010)
def rows = sql.rows(q.toString(),[eoyts,eoyts,3]) as List
for (row in rows) {
   [row.FROM_YEAR..row.TO_YEAR].each {
   println "${row.CELL}, ${row.DESIGN_NUMBER}, ${row.CONSTRUCTION_BEGAN_DATE}, ${row.CELL_END_DATE}, ${it}"   
   }
}
"${rows.size()} cells found."



def cells = []

def dataSource = ctx.dataSource
def sql = Sql.newInstance(dataSource)
def q = """
SELECT ID,CELL,DESIGN_NUMBER DESIGN,CONSTRUCTION_BEGAN_DATE,NVL(CELL_END_DATE,?) CELL_END_DATE,TO_NUMBER(TO_CHAR(CONSTRUCTION_BEGAN_DATE,'yyyy')) FROM_YEAR,TO_NUMBER(TO_CHAR(NVL(CELL_END_DATE, ?),'yyyy')) TO_YEAR
FROM (SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) CELL_END_DATE,DESIGN_NUMBER FROM (SELECT ID,CELL_NUMBER CELL,SUBSTR(CLASS,24) CELL_TYPE,(SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=C.ID) CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,DEMOLISHED_DATE,CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1 WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2 WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3 WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4 WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5 ELSE 1 END DESIGN_NUMBER FROM MNR.CELL C))
WHERE CELL <= ? ORDER BY CELL, CONSTRUCTION_BEGAN_DATE
"""
def eoyts = MrUtils.endOfYearSqlTimestamp(2010)
def rows = sql.rows(q.toString(),[eoyts,eoyts,3]) as List
for (row in rows) {
   def designCell = [:]
   designCell.put("id",row.ID)
   designCell.put("cell",row.CELL)
   designCell.put("design",row.DESIGN)
   designCell.put("from_date",row.CONSTRUCTION_BEGAN_DATE)
   designCell.put("to_date",row.CELL_END_DATE)
   designCell.put("years", [row.FROM_YEAR..row.TO_YEAR])
   cells << designCell
}

import us.mn.state.dot.mnroad.*

def ds = ctx.getBean("sensorQueryService")
def cells = ds.cells(2010)
cells.each {
   println it
}
"${cells.size()} cells."



SELECT ID,CELL
,CONSTRUCTION_BEGAN_DATE FIRST_LAYER_DATE
,CONSTRUCTION_ENDED_DATE
,NVL(CELL_END_DATE, sysdate)
,DESIGN_NUMBER 
FROM (SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) CELL_END_DATE,DESIGN_NUMBER FROM (SELECT ID,CELL_NUMBER CELL,SUBSTR(CLASS,24) CELL_TYPE,(SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=CL.ID) CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,DEMOLISHED_DATE,CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1 WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2 WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3 WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4 WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5 ELSE 1 END DESIGN_NUMBER FROM MNR.CELL C)) 
WHERE CELL >= 1 and cell <= 8 ORDER BY CELL, CONSTRUCTION_BEGAN_DATE

SELECT ID,CELL,CONSTRUCTION_BEGAN_DATE FIRST_LAYER_DATE,CONSTRUCTION_ENDED_DATE,CELL_END_DATE  TO_DATE,DESIGN_NUMBER FROM (SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) CELL_END_DATE,DESIGN_NUMBER FROM (SELECT ID,CELL_NUMBER CELL,SUBSTR(CLASS,24) CELL_TYPE,(SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=C.ID) CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,DEMOLISHED_DATE,CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1 WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2 WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3 WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4 WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5 ELSE 1 END DESIGN_NUMBER FROM MNR.CELL C)) 
  WHERE TO_NUMBER(TO_CHAR(CONSTRUCTION_BEGAN_DATE,'YYYY')) BETWEEN ? AND ? OR 
        TO_NUMBER(TO_CHAR(CELL_END_DATE,'YYYY')) BETWEEN ? AND ?
ORDER BY CELL, CONSTRUCTION_BEGAN_DATE

SELECT ID,CELL,CONSTRUCTION_BEGAN_DATE FIRST_LAYER_DATE,CONSTRUCTION_ENDED_DATE,CELL_END_DATE  TO_DATE,DESIGN_NUMBER FROM (SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) CELL_END_DATE,DESIGN_NUMBER FROM (SELECT ID,CELL_NUMBER CELL,SUBSTR(CLASS,24) CELL_TYPE,(SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=C.ID) CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,DEMOLISHED_DATE,CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1 WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2 WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3 WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4 WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5 ELSE 1 END DESIGN_NUMBER FROM MNR.CELL C)) 
  WHERE 2009 BETWEEN TO_NUMBER(TO_CHAR(CONSTRUCTION_BEGAN_DATE,'YYYY')) AND TO_NUMBER(TO_CHAR(CELL_END_DATE,'YYYY')) 
ORDER BY CELL, CONSTRUCTION_BEGAN_DATE

SELECT ID,CELL,CONSTRUCTION_BEGAN_DATE FIRST_LAYER_DATE,CONSTRUCTION_ENDED_DATE,CELL_END_DATE  TO_DATE,DESIGN_NUMBER FROM (SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) CELL_END_DATE,DESIGN_NUMBER FROM (SELECT ID,CELL_NUMBER CELL,SUBSTR(CLASS,24) CELL_TYPE,(SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=C.ID) CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,DEMOLISHED_DATE,CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1 WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2 WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3 WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4 WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5 ELSE 1 END DESIGN_NUMBER FROM MNR.CELL C)) 
  WHERE 2009 BETWEEN TO_NUMBER(TO_CHAR(CONSTRUCTION_BEGAN_DATE,'YYYY')) AND TO_NUMBER(TO_CHAR(NVL(CELL_END_DATE,SYSDATE),'YYYY')) 
ORDER BY CELL, CONSTRUCTION_BEGAN_DATE

SELECT UNIQUE CELL,TABLE_NAME, TO_CHAR(FROM_DAY,'yyyy-mm-dd') FR_DATE, TO_CHAR(TO_DAY,'yyyy-mm-dd') TO_DATE 
FROM MNR.SENSOR_COUNTS 
WHERE SUBSTR(TABLE_NAME,1,2)=? AND TO_NUMBER(TO_CHAR(FROM_DAY,'yyyy'))>=? AND TO_NUMBER(TO_CHAR(TO_DAY,'yyyy'))<=? 
AND CELL >= ?
ORDER BY TABLE_NAME,CELL,FR_DATE

SELECT CELL "Cell", DAY "Day", HOUR "Hour", QHR "Qhr", MINUTE "Minute","s_1","s_2","s_3","s_4","s_5","s_6","s_7","s_8","s_9","s_10","s_11","s_12","s_13","s_14","s_15","s_16","s_17","s_18","s_19","s_20","s_21","s_22","s_23","s_24","s_25","s_26","s_27","s_28","s_29","s_30","s_31","s_32","s_33","s_34","s_35","s_36","s_37","s_38","s_39","s_40","s_41","s_42","s_43","s_44","s_45","s_46","s_47","s_48","s_49","s_50","s_51","s_52","s_53","s_54","s_55","s_56","s_57","s_58","s_59","s_60","s_61","s_62","s_63","s_64","s_65","s_66","s_67","s_68","s_69","s_70","s_71","s_72","s_73","s_74","s_75" FROM (SELECT CELL,DAY,HOUR,QHR,MINUTE,MIN(DECODE(SEQ,1,VALUE)) AS "s_1",MIN(DECODE(SEQ,2,VALUE)) AS "s_2",MIN(DECODE(SEQ,3,VALUE)) AS "s_3",MIN(DECODE(SEQ,4,VALUE)) AS "s_4",MIN(DECODE(SEQ,5,VALUE)) AS "s_5",MIN(DECODE(SEQ,6,VALUE)) AS "s_6",MIN(DECODE(SEQ,7,VALUE)) AS "s_7",MIN(DECODE(SEQ,8,VALUE)) AS "s_8",MIN(DECODE(SEQ,9,VALUE)) AS "s_9",MIN(DECODE(SEQ,10,VALUE)) AS "s_10",MIN(DECODE(SEQ,11,VALUE)) AS "s_11",MIN(DECODE(SEQ,12,VALUE)) AS "s_12",MIN(DECODE(SEQ,13,VALUE)) AS "s_13",MIN(DECODE(SEQ,14,VALUE)) AS "s_14",MIN(DECODE(SEQ,15,VALUE)) AS "s_15",MIN(DECODE(SEQ,16,VALUE)) AS "s_16",MIN(DECODE(SEQ,17,VALUE)) AS "s_17",MIN(DECODE(SEQ,18,VALUE)) AS "s_18",MIN(DECODE(SEQ,19,VALUE)) AS "s_19",MIN(DECODE(SEQ,20,VALUE)) AS "s_20",MIN(DECODE(SEQ,21,VALUE)) AS "s_21",MIN(DECODE(SEQ,22,VALUE)) AS "s_22",MIN(DECODE(SEQ,23,VALUE)) AS "s_23",MIN(DECODE(SEQ,24,VALUE)) AS "s_24",MIN(DECODE(SEQ,25,VALUE)) AS "s_25",MIN(DECODE(SEQ,26,VALUE)) AS "s_26",MIN(DECODE(SEQ,27,VALUE)) AS "s_27",MIN(DECODE(SEQ,28,VALUE)) AS "s_28",MIN(DECODE(SEQ,29,VALUE)) AS "s_29",MIN(DECODE(SEQ,30,VALUE)) AS "s_30",MIN(DECODE(SEQ,31,VALUE)) AS "s_31",MIN(DECODE(SEQ,32,VALUE)) AS "s_32",MIN(DECODE(SEQ,33,VALUE)) AS "s_33",MIN(DECODE(SEQ,34,VALUE)) AS "s_34",MIN(DECODE(SEQ,35,VALUE)) AS "s_35",MIN(DECODE(SEQ,36,VALUE)) AS "s_36",MIN(DECODE(SEQ,37,VALUE)) AS "s_37",MIN(DECODE(SEQ,38,VALUE)) AS "s_38",MIN(DECODE(SEQ,39,VALUE)) AS "s_39",MIN(DECODE(SEQ,40,VALUE)) AS "s_40",MIN(DECODE(SEQ,41,VALUE)) AS "s_41",MIN(DECODE(SEQ,42,VALUE)) AS "s_42",MIN(DECODE(SEQ,43,VALUE)) AS "s_43",MIN(DECODE(SEQ,44,VALUE)) AS "s_44",MIN(DECODE(SEQ,45,VALUE)) AS "s_45",MIN(DECODE(SEQ,46,VALUE)) AS "s_46",MIN(DECODE(SEQ,47,VALUE)) AS "s_47",MIN(DECODE(SEQ,48,VALUE)) AS "s_48",MIN(DECODE(SEQ,49,VALUE)) AS "s_49",MIN(DECODE(SEQ,50,VALUE)) AS "s_50",MIN(DECODE(SEQ,51,VALUE)) AS "s_51",MIN(DECODE(SEQ,52,VALUE)) AS "s_52",MIN(DECODE(SEQ,53,VALUE)) AS "s_53",MIN(DECODE(SEQ,54,VALUE)) AS "s_54",MIN(DECODE(SEQ,55,VALUE)) AS "s_55",MIN(DECODE(SEQ,56,VALUE)) AS "s_56",MIN(DECODE(SEQ,57,VALUE)) AS "s_57",MIN(DECODE(SEQ,58,VALUE)) AS "s_58",MIN(DECODE(SEQ,59,VALUE)) AS "s_59",MIN(DECODE(SEQ,60,VALUE)) AS "s_60",MIN(DECODE(SEQ,61,VALUE)) AS "s_61",MIN(DECODE(SEQ,62,VALUE)) AS "s_62",MIN(DECODE(SEQ,63,VALUE)) AS "s_63",MIN(DECODE(SEQ,64,VALUE)) AS "s_64",MIN(DECODE(SEQ,65,VALUE)) AS "s_65",MIN(DECODE(SEQ,66,VALUE)) AS "s_66",MIN(DECODE(SEQ,67,VALUE)) AS "s_67",MIN(DECODE(SEQ,68,VALUE)) AS "s_68",MIN(DECODE(SEQ,69,VALUE)) AS "s_69",MIN(DECODE(SEQ,70,VALUE)) AS "s_70",MIN(DECODE(SEQ,71,VALUE)) AS "s_71",MIN(DECODE(SEQ,72,VALUE)) AS "s_72",MIN(DECODE(SEQ,73,VALUE)) AS "s_73",MIN(DECODE(SEQ,74,VALUE)) AS "s_74",MIN(DECODE(SEQ,75,VALUE)) AS "s_75" FROM MNR.TC_VALUES_1996 WHERE cell = 1 AND DAY BETWEEN '1-jan-1996' and '31-jan-1996' GROUP BY CELL,DAY,HOUR,QHR,MINUTE) ORDER BY CELL,DAY,HOUR,QHR,MINUTE

SELECT c.id,c.cell_number cell, s.seq FROM mnr.cell c join mnr.lane ln on ln.cell_id=c.id
join mnr.layer l on l.lane_id=ln.id 
join mnr.sensor s on s.layer_id=l.id
join mnr.sensor_model m on s.sensor_model_id = m.id
where c.cell_number = 1 and m.model='TC'

SELECT UNIQUE CELL,TABLE_NAME, TO_CHAR(FROM_DAY,'yyyy-mm-dd') FR_DATE, TO_CHAR(TO_DAY,'yyyy-mm-dd') TO_DATE,AS_OF 
FROM MNR.SENSOR_COUNTS WHERE 
SUBSTR(TABLE_NAME,1,2)='TC' AND TO_NUMBER(TO_CHAR(FROM_DAY,'yyyy'))>=1996 AND TO_NUMBER(TO_CHAR(TO_DAY,'yyyy'))<=2010
ORDER BY TABLE_NAME,CELL,FR_DATE

SELECT ID CELL_ID,CELL,DESIGN_NUMBER DESIGN,CONSTRUCTION_BEGAN_DATE,NVL(CELL_END_DATE,'31-DEC-2010') CELL_END_DATE,TO_NUMBER(TO_CHAR(CONSTRUCTION_BEGAN_DATE,'yyyy')) FROM_YEAR,TO_NUMBER(TO_CHAR(NVL(CELL_END_DATE, '31-DEC-2010'),'yyyy')) TO_YEAR
 FROM (SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) CELL_END_DATE,DESIGN_NUMBER FROM (SELECT ID,CELL_NUMBER CELL,SUBSTR(CLASS,24) CELL_TYPE,(SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=C.ID) CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,DEMOLISHED_DATE,CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1 WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2 WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3 WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4 WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5 ELSE 1 END DESIGN_NUMBER FROM MNR.CELL C))
 ORDER BY CELL, CONSTRUCTION_BEGAN_DATE

SELECT C.CELL_ID
  , C.CELL
  , C.DESIGN
  , C.CONSTRUCTION_BEGAN_DATE FROM_DATE
  , C.CELL_END_DATE TO_DATE
  , C.FROM_YEAR
  , C.TO_YEAR
  , M.MODEL
  , S.SEQ 
FROM MNR.LANE LN
JOIN MNR.LAYER L ON L.LANE_ID=LN.ID 
JOIN MNR.SENSOR S ON S.LAYER_ID=L.ID
JOIN MNR.SENSOR_MODEL M ON S.SENSOR_MODEL_ID = M.ID
join (SELECT ID CELL_ID,CELL,CELL_TYPE,DESIGN_NUMBER DESIGN,CONSTRUCTION_BEGAN_DATE,NVL(CELL_END_DATE,'31-DEC-2010') CELL_END_DATE,TO_NUMBER(TO_CHAR(CONSTRUCTION_BEGAN_DATE,'yyyy')) FROM_YEAR,TO_NUMBER(TO_CHAR(NVL(CELL_END_DATE, '31-DEC-2010'),'yyyy')) TO_YEAR
 FROM (
   SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) CELL_END_DATE,DESIGN_NUMBER 
     FROM (
     
       SELECT ID
         ,CELL_NUMBER CELL
         ,SUBSTR(CLASS,24) CELL_TYPE
         ,(SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=CL.ID) CONSTRUCTION_BEGAN_DATE
         ,CONSTRUCTION_ENDED_DATE
         ,DEMOLISHED_DATE
         ,CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY CL.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1 
         WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY CL.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2 
         WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY CL.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3 
         WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY CL.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4 
         WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY CL.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5 ELSE 1 END DESIGN_NUMBER 
         FROM MNR.CELL CL
       )
     )
   ) C ON C.CELL_ID=LN.CELL_ID
WHERE C.CELL = 1
--and m.model='TC'

SELECT ID
,CELL
,CELL_TYPE
,FIRST_LAYER_DATE CONSTRUCTION_BEGAN_DATE
,CONSTRUCTION_ENDED_DATE
,TO_DATE DEMOLISHED_DATE
,DESIGN_NUMBER
 FROM MNR.CELL_DESIGN CD
WHERE CD.CELL = 1

ID
CELL
CELL_TYPE
FIRST_LAYER_DATE
CONSTRUCTION_ENDED_DATE
TO_DATE
DESIGN_NUMBER



       SELECT ID
         ,CELL_NUMBER CELL
         ,SUBSTR(CLASS,24) CELL_TYPE
         ,(SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=CL.ID) CONSTRUCTION_BEGAN_DATE
         ,CONSTRUCTION_ENDED_DATE
         ,DEMOLISHED_DATE
         ,CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY CL.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1 
         WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY CL.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2 
         WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY CL.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3 
         WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY CL.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4 
         WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY CL.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5 ELSE 1 END DESIGN_NUMBER 
       FROM MNR.CELL CL WHERE CELL_NUMBER=1

SELECT *
 FROM MNR.CELL_DESIGN CD
WHERE CD.CELL = 1       

SELECT C.CELL_ID
  , C.CELL
  , C.DESIGN
  , C.CONSTRUCTION_BEGAN_DATE FROM_DATE
  , C.CELL_END_DATE TO_DATE
  , C.FROM_YEAR
  , C.TO_YEAR
  , M.MODEL
  , S.SEQ 
FROM MNR.LANE LN
JOIN MNR.LAYER L ON L.LANE_ID=LN.ID 
JOIN MNR.SENSOR S ON S.LAYER_ID=L.ID
JOIN MNR.SENSOR_MODEL M ON S.SENSOR_MODEL_ID = M.ID
join (SELECT ID CELL_ID,CELL,CELL_TYPE,DESIGN_NUMBER DESIGN,CONSTRUCTION_BEGAN_DATE,NVL(CELL_END_DATE,'31-DEC-2010') CELL_END_DATE,TO_NUMBER(TO_CHAR(CONSTRUCTION_BEGAN_DATE,'yyyy')) FROM_YEAR,TO_NUMBER(TO_CHAR(NVL(CELL_END_DATE, '31-DEC-2010'),'yyyy')) TO_YEAR
 FROM (
   SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) CELL_END_DATE,DESIGN_NUMBER 
     FROM (
SELECT ID
,CELL
,CELL_TYPE
,FIRST_LAYER_DATE CONSTRUCTION_BEGAN_DATE
,CONSTRUCTION_ENDED_DATE
,TO_DATE DEMOLISHED_DATE
,DESIGN_NUMBER
 FROM MNR.CELL_DESIGN CD
       )
     )
   ) C ON C.CELL_ID=LN.CELL_ID
WHERE C.CELL = 1

SELECT C.ID,C.CELL_NUMBER,M.MODEL,S.ID,S.SEQ,S.DATE_REMOVED
FROM MNR.CELL C 
JOIN MNR.LANE LN
ON C.ID=LN.CELL_ID
JOIN MNR.LAYER L ON L.LANE_ID=LN.ID 
JOIN MNR.SENSOR S ON S.LAYER_ID=L.ID
JOIN MNR.SENSOR_MODEL M ON S.SENSOR_MODEL_ID = M.ID
WHERE C.CELL_NUMBER = 1 AND M.MODEL='TC'

SELECT CELL, SEQ, MAX(DAY) MOST_RECENT_VALUE,COUNT(*) FROM MNR.TC_VALUES_ALL WHERE CELL=2 AND SEQ IN (1,2,3,4,5,6,7,8,9,10,11) AND DAY > '17-NOV-2007'

SELECT 

SELECT C.CELL_NUMBER CELL,S.SEQ,S.DATE_REMOVED
FROM MNR.CELL C 
JOIN MNR.LANE LN
ON C.ID=LN.CELL_ID
JOIN MNR.LAYER L ON L.LANE_ID=LN.ID 
JOIN MNR.SENSOR S ON S.LAYER_ID=L.ID
JOIN MNR.SENSOR_MODEL M ON S.SENSOR_MODEL_ID = M.ID
WHERE M.MODEL='TC' AND S.DATE_REMOVED IS NOT NULL

JOIN (SELECT MAX(DAY) MOST_RECENT_VALUE,COUNT(*) FROM MNR.TC_VALUES_ALL T WHERE T.CELL=C.CELL_NUMBER AND T.SEQ=S.SEQ AND T.DAY > S.DATE_REMOVED) V 
WHERE C.CELL_NUMBER = 1 AND M.MODEL='TC' AND S.DATE_REMOVED IS NOT NULL

SELECT * FROM (
SELECT C.CELL_NUMBER CELL,S.SEQ,S.DATE_REMOVED
FROM MNR.CELL C 
JOIN MNR.LANE LN
ON C.ID=LN.CELL_ID
JOIN MNR.LAYER L ON L.LANE_ID=LN.ID 
JOIN MNR.SENSOR S ON S.LAYER_ID=L.ID
JOIN MNR.SENSOR_MODEL M ON S.SENSOR_MODEL_ID = M.ID
WHERE M.MODEL='TC' AND S.DATE_REMOVED IS NOT NULL
) D JOIN
(
SELECT CELL,SEQ,TO_CHAR(MAX(DAY),'mm/dd/yyyy') MOST_RECENT_VALUE,COUNT(*) FROM MNR.TC_VALUES_2006 T GROUP BY CELL,SEQ
) V
ON D.CELL=V.CELL AND D.SEQ=V.SEQ
ORDER BY CELL,SEQ


SELECT CELL,SEQ,MAX(DAY) MOST_RECENT_VALUE,COUNT(*) FROM MNR.TC_VALUES_2006 T GROUP BY CELL,SEQ

ORDER BY CELL,SEQ

SELECT CELL "Cell", DAY "Day", HOUR "Hour", QHR "Qhr", MINUTE "Minute","s_1","s_2","s_3","s_4","s_5","s_6","s_7","s_8","s_9","s_10","s_11","s_12","s_13","s_14","s_15","s_16","s_17","s_18","s_19","s_20","s_21","s_22","s_23","s_24","s_25","s_26","s_27","s_28","s_29","s_30","s_31","s_32","s_33","s_34","s_35","s_36","s_37","s_38","s_39","s_40","s_41","s_42","s_43","s_44","s_45","s_46","s_47","s_48","s_49","s_50","s_51","s_52","s_53","s_54","s_55","s_56","s_57","s_58","s_59","s_60","s_61","s_62","s_63","s_64","s_65","s_66","s_67","s_68","s_69","s_70","s_71","s_72","s_73","s_74","s_75" FROM (SELECT CELL,DAY,HOUR,QHR,MINUTE,MIN(DECODE(SEQ,1,VALUE)) AS "s_1",MIN(DECODE(SEQ,2,VALUE)) AS "s_2",MIN(DECODE(SEQ,3,VALUE)) AS "s_3",MIN(DECODE(SEQ,4,VALUE)) AS "s_4",MIN(DECODE(SEQ,5,VALUE)) AS "s_5",MIN(DECODE(SEQ,6,VALUE)) AS "s_6",MIN(DECODE(SEQ,7,VALUE)) AS "s_7",MIN(DECODE(SEQ,8,VALUE)) AS "s_8",MIN(DECODE(SEQ,9,VALUE)) AS "s_9",MIN(DECODE(SEQ,10,VALUE)) AS "s_10",MIN(DECODE(SEQ,11,VALUE)) AS "s_11",MIN(DECODE(SEQ,12,VALUE)) AS "s_12",MIN(DECODE(SEQ,13,VALUE)) AS "s_13",MIN(DECODE(SEQ,14,VALUE)) AS "s_14",MIN(DECODE(SEQ,15,VALUE)) AS "s_15",MIN(DECODE(SEQ,16,VALUE)) AS "s_16",MIN(DECODE(SEQ,17,VALUE)) AS "s_17",MIN(DECODE(SEQ,18,VALUE)) AS "s_18",MIN(DECODE(SEQ,19,VALUE)) AS "s_19",MIN(DECODE(SEQ,20,VALUE)) AS "s_20",MIN(DECODE(SEQ,21,VALUE)) AS "s_21",MIN(DECODE(SEQ,22,VALUE)) AS "s_22",MIN(DECODE(SEQ,23,VALUE)) AS "s_23",MIN(DECODE(SEQ,24,VALUE)) AS "s_24",MIN(DECODE(SEQ,25,VALUE)) AS "s_25",MIN(DECODE(SEQ,26,VALUE)) AS "s_26",MIN(DECODE(SEQ,27,VALUE)) AS "s_27",MIN(DECODE(SEQ,28,VALUE)) AS "s_28",MIN(DECODE(SEQ,29,VALUE)) AS "s_29",MIN(DECODE(SEQ,30,VALUE)) AS "s_30",MIN(DECODE(SEQ,31,VALUE)) AS "s_31",MIN(DECODE(SEQ,32,VALUE)) AS "s_32",MIN(DECODE(SEQ,33,VALUE)) AS "s_33",MIN(DECODE(SEQ,34,VALUE)) AS "s_34",MIN(DECODE(SEQ,35,VALUE)) AS "s_35",MIN(DECODE(SEQ,36,VALUE)) AS "s_36",MIN(DECODE(SEQ,37,VALUE)) AS "s_37",MIN(DECODE(SEQ,38,VALUE)) AS "s_38",MIN(DECODE(SEQ,39,VALUE)) AS "s_39",MIN(DECODE(SEQ,40,VALUE)) AS "s_40",MIN(DECODE(SEQ,41,VALUE)) AS "s_41",MIN(DECODE(SEQ,42,VALUE)) AS "s_42",MIN(DECODE(SEQ,43,VALUE)) AS "s_43",MIN(DECODE(SEQ,44,VALUE)) AS "s_44",MIN(DECODE(SEQ,45,VALUE)) AS "s_45",MIN(DECODE(SEQ,46,VALUE)) AS "s_46",MIN(DECODE(SEQ,47,VALUE)) AS "s_47",MIN(DECODE(SEQ,48,VALUE)) AS "s_48",MIN(DECODE(SEQ,49,VALUE)) AS "s_49",MIN(DECODE(SEQ,50,VALUE)) AS "s_50",MIN(DECODE(SEQ,51,VALUE)) AS "s_51",MIN(DECODE(SEQ,52,VALUE)) AS "s_52",MIN(DECODE(SEQ,53,VALUE)) AS "s_53",MIN(DECODE(SEQ,54,VALUE)) AS "s_54",MIN(DECODE(SEQ,55,VALUE)) AS "s_55",MIN(DECODE(SEQ,56,VALUE)) AS "s_56",MIN(DECODE(SEQ,57,VALUE)) AS "s_57",MIN(DECODE(SEQ,58,VALUE)) AS "s_58",MIN(DECODE(SEQ,59,VALUE)) AS "s_59",MIN(DECODE(SEQ,60,VALUE)) AS "s_60",MIN(DECODE(SEQ,61,VALUE)) AS "s_61",MIN(DECODE(SEQ,62,VALUE)) AS "s_62",MIN(DECODE(SEQ,63,VALUE)) AS "s_63",MIN(DECODE(SEQ,64,VALUE)) AS "s_64",MIN(DECODE(SEQ,65,VALUE)) AS "s_65",MIN(DECODE(SEQ,66,VALUE)) AS "s_66",MIN(DECODE(SEQ,67,VALUE)) AS "s_67",MIN(DECODE(SEQ,68,VALUE)) AS "s_68",MIN(DECODE(SEQ,69,VALUE)) AS "s_69",MIN(DECODE(SEQ,70,VALUE)) AS "s_70",MIN(DECODE(SEQ,71,VALUE)) AS "s_71",MIN(DECODE(SEQ,72,VALUE)) AS "s_72",MIN(DECODE(SEQ,73,VALUE)) AS "s_73",MIN(DECODE(SEQ,74,VALUE)) AS "s_74",MIN(DECODE(SEQ,75,VALUE)) AS "s_75" FROM MNR.TC_VALUES_1996 WHERE cell = ? AND DAY BETWEEN ? and ? GROUP BY CELL,DAY,HOUR,QHR,MINUTE) ORDER BY CELL,DAY,HOUR,QHR,MINUTE

import us.mn.state.dot.mnroad.*

def ds = ctx.getBean("sensorQueryService")
def cells = ds.cells(2010)
cells.each {
   println it
}
"${cells.size()} cells."

SELECT CELL,min(DAY),MAX(DAY),COUNT(*) NUM_VALUES FROM MNR.TC_VALUES_ALL GROUP BY CELL
 1	1993-01-01 2010-12-03 5,018,437
 2	1993-02-13 2011-06-22 5,523,851
 3	1993-01-01 2011-06-22 5,495,160
 4	1993-01-01 2011-06-22 25,155,803
 5	1993-09-20 2008-04-23 4,417,845
 6	1993-01-05 2007-11-16 26,586,607
 7	1993-01-01 2007-10-06 26,677,317
 8	1993-01-01 2011-06-22 5,420,628
 9	1993-01-05 2011-06-22 5,467,477
10	1994-04-11 2010-03-18 16,845,837
11	1994-04-01 2007-11-16 3,976,487
12	1994-04-11 2010-11-10 18,655,950
13	1994-04-11 2007-11-16 3,968,163
14	1994-04-11 2007-08-01 3,508,286
15	1994-04-11 2008-12-18 13,068,644
16	1994-04-11 2011-06-22 5,030,550
17	1994-04-11 2011-06-22 23,653,295
18	1994-01-04 2011-06-22 4,460,024
19	1994-01-04 2011-06-22 5,035,852
20	1994-03-28 2011-06-22 5,057,876
21	1994-03-28 2011-06-22 5,073,170
22	1994-01-04 2011-06-22 25,874,678
23	1994-01-01 2011-06-22 5,484,997
24	1994-01-02 2011-06-22 4,724,684
25	1994-01-02 2006-11-08 11,981,314
26	1994-01-01 2008-04-23 6,480,225
27	1994-01-26 2006-06-08 9,483,717
28	1994-01-01 2011-06-22 8,045,015
29	1994-01-12 2007-07-11 3,906,253
30	1994-01-11 2007-07-10 13,100,497
31	1994-03-25 2011-06-22 7,458,474
32	1994-04-14 2010-09-27 8,316,972
33	1994-01-02 2011-06-22 6,860,319
34	1994-01-01 2011-06-22 7,807,780
35	1994-01-26 2011-06-22 9,194,731
36	1994-01-01 2011-06-22 4,715,692
37	1994-01-12 2011-06-22 5,192,543
38	1994-01-11 2011-06-22 5,378,527
39	1994-03-25 2011-06-22 18,224,611
40	1994-04-14 2011-06-22 5,311,421
52	1994-11-05 2010-11-08 5,609,272
53	2000-06-30 2011-06-22 6,606,496
54	2004-12-26 2011-06-22 3,637,456
60	2004-10-25 2011-06-22 3,124,310
62	2005-01-08 2011-06-22 3,098,396
64	2005-11-03 2011-06-21 772,176
70	2010-05-06 2011-06-22 2,825,952
71	2010-05-05 2011-06-22 3,140,600
72	2010-05-06 2011-06-22 2,824,920
77	2007-11-20 2011-06-22 1,944,192
78	2007-11-19 2011-06-22 1,993,344
79	2008-04-17 2011-06-22 1,748,672
80	2002-07-05 2003-03-27 1,852,608
81	2005-07-13 2005-07-16 136,416
82	2005-08-09 2005-10-17 118,504
83	2007-12-14 2010-12-08 3,296,544
84	2007-11-20 2010-12-08 1,657,392
85	2008-10-21 2011-06-22 1,492,272
86	2008-10-21 2011-06-22 1,491,136
87	2010-10-14 2011-06-22 572,920
88	2008-10-23 2011-06-22 1,488,880
89	2008-10-23 2011-06-22 1,488,880
93	1998-01-01 2004-09-09 2,936,765
95	1998-01-01 2004-09-09 2,928,419
97	1998-01-01 2008-09-04 6,237,368
98	1998-01-20 1999-07-20 301,568
99	1996-10-02 1996-10-03 96
106	2008-11-10 2011-06-22 4,324,480
113	2008-10-13 2011-06-22 1,506,384
205	2008-10-04 2011-06-22 2,279,424
206	2008-12-23 2011-06-22 1,397,664
213	2008-10-09 2011-06-22 1,510,192
305	2008-10-04 2011-06-22 1,520,944
313	2008-10-09 2011-06-22 755,368
414	2008-11-03 2008-12-23 154,432
601	2008-10-06 2008-12-08 300,832
914	2008-12-23 2011-06-22 2,787,008

SELECT X.CELL, MIN(Y.DAY),MAX(Y.DAY),X.CELL_FROM_DATE, X.CELL_TO_DATE, COUNT(*)                                    
FROM (                                                                                                             
SELECT B.CELL, MIN(FROM_DATE) CELL_FROM_DATE, NVL(MAX(TO_DATE),'12-DEC-2010') CELL_TO_DATE FROM                    
MNR.CELL_BOUNDS B                                                                                                  
GROUP BY CELL) X                                                                                                   
JOIN MNR.TC_VALUES_ALL Y ON Y.CELL=X.CELL AND Y.DAY NOT BETWEEN X.CELL_FROM_DATE AND X.CELL_TO_DATE GROUP BY X.CELL

CELL	MIN(Y.DAY)	MAX(Y.DAY)	COUNT(*)                 
52	1994-11-05    1995-04-05  6,760

SELECT X.CELL, MIN(T.DAY),MAX(T.DAY)
--,X.CELL_FROM_DATE, X.CELL_TO_DATE
,COUNT(*) FROM
(                                                                                                                                            
SELECT CELL, MIN(FROM_DATE) CELL_FROM_DATE, NVL(MAX(TO_DATE),'12-DEC-2010') CELL_TO_DATE FROM (                                              
select Z.ID,Z.CELL,Z.DESIGN,Z.CELL_TYPE,Z.FROM_DATE,NVL(Z.TO_DATE,'31-DEC-2010') TO_DATE,Z.START_STATION,Z.END_STATION from (                
SELECT D.ID, D.CELL, D.DESIGN, D.CELL_TYPE, D.CONSTRUCTION_BEGAN_DATE FROM_DATE                                                              
  , NVL(D.CELL_END_DATE,(SELECT UNIQUE FROM_DATE_OVER-1 TO_DATE FROM MNR.CELL_ON_CELL CC WHERE CC.ID_UNDER=D.ID)) TO_DATE                    
  , START_STATION,END_STATION FROM                                                                                                           
      (SELECT ID, CELL, DESIGN, CELL_TYPE                                                                                                    
        , CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE                                                                                    
        , NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) CELL_END_DATE
        , START_STATION,END_STATION FROM                                                                                                     
        (SELECT C.ID                                                                                                                         
	        , C.CELL_NUMBER CELL                                                                                                                
	        , CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1                  
	          WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2                       
	          WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3                       
	          WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4                       
	          WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5                       
	          ELSE 1                                                                                                                            
	          END DESIGN                                                                                                                        
	        , SUBSTR(C.CLASS,24) CELL_TYPE                                                                                                      
	        , (SELECT FIRST_LAYER_DATE+1 FROM MNR.CELLS WHERE ID=C.ID) CONSTRUCTION_BEGAN_DATE                                                  
		        , C.CONSTRUCTION_ENDED_DATE                                                                                                        
		        , C.DEMOLISHED_DATE                                                                                                                
		        , C.START_STATION                                                                                                                  
		        , C.END_STATION                                                                                                                    
        FROM MNR.CELL C                                                                                                                      
        )                                                                                                                                    
      ) D                                                                                                                                    
) Z                                                                                                                                          
) GROUP BY CELL                                                                                                                              
) X                                                                                                                                          
JOIN MNR.TC_VALUES_ALL T ON T.CELL=X.CELL AND T.DAY NOT BETWEEN X.CELL_FROM_DATE AND X.CELL_TO_DATE GROUP BY X.CELL                          
                                                                                                                                             
CELL	TC.TO_DAY   TC.TO_DAY     COUNT(*)
  2		2011-01-01 	2011-06-22 	  264,240
  3		2011-01-01 	2011-06-22 	  263,152
  4		2011-01-01 	2011-06-22 	  264,256
  8		2011-01-01 	2011-06-22 	  181,709
  9		2011-01-01 	2011-06-22 	  198,240
 16		2011-01-01 	2011-06-22 	  264,288
 17		2011-01-01 	2011-06-22 	  264,256
 18		2011-01-01 	2011-06-22 	  264,256
 19		2011-01-01 	2011-06-22 	  264,272
 20		2011-01-01 	2011-06-22 	  264,304
 21		2011-01-01 	2011-06-22 	  264,304
 22		2011-01-01 	2011-06-22 	  264,256
 23		2011-01-01 	2011-06-22 	  264,256
 24		2011-01-01 	2011-06-22 	  264,256
 28		2011-01-01 	2011-06-22 	   48,507
 31		2011-01-01 	2011-06-22 	  264,208
 33		2011-01-01 	2011-06-22 	  264,192
 34		2011-01-01 	2011-06-22 	  264,192
 35		2011-01-01 	2011-06-22 	  264,176
 36		2011-01-01 	2011-06-22 	  148,662
 37		2011-01-01 	2011-06-22 	  181,687
 38		2011-01-01 	2011-06-22 	  181,687
 39		2011-01-01 	2011-06-22 	  264,272
 40		2011-01-01 	2011-06-22 	  181,687
 52		1994-11-05 	1995-04-05 	    6,760
 53		2011-01-01 	2011-06-22 	  396,360
 54		2011-01-01 	2011-06-22 	  264,208
 60		2011-01-01 	2011-06-22 	  204,358
 62		2011-01-01 	2011-06-22 	  229,950
 64		2011-01-01 	2011-06-21 	   66,000
 70		2011-01-01 	2011-06-22 	1,189,368
 71		2011-01-01 	2011-06-22 	1,321,520
 72		2011-01-01 	2011-06-22 	1,189,656
 77		2011-01-01 	2011-06-22 	  264,288
 78		2011-01-01 	2011-06-22 	  264,288
 79		2011-01-01 	2011-06-22 	  264,192
 85		2011-01-01 	2011-06-22 	  263,296
 86		2011-01-01 	2011-06-22 	  263,296
 87		2011-01-01 	2011-06-22 	  396,448
 88		2011-01-01 	2011-06-22 	  264,208
 89		2011-01-01 	2011-06-22 	  264,208
106		2011-01-01 	2011-06-22 	  792,816
113		2011-01-01 	2011-06-22 	  264,240
205		2011-01-01 	2011-06-22 	  396,360
206		2011-01-01 	2011-06-22 	  264,272
213		2011-01-01 	2011-06-22 	  264,240
305		2011-01-01 	2011-06-22 	  264,240
313		2011-01-01 	2011-06-22 	  132,120
914		2011-01-01 	2011-06-22 	  528,576

CREATE OR REPLACE VIEW CELL_SENSORS AS

  SELECT CELLS.ID CELL_ID
    , CELLS.CELL
    , CELLS.DESIGN
    , CELLS.CELL_TYPE
    , CELLS.FROM_DATE
    , CELLS.CELL_END_DATE
    , LN.NAME LANE
    , M.BASIC_MATERIAL
    , ROUND((LY.THICKNESS/2.54),2) THICKNESS_IN
    , SM.MODEL
    , S.ID SENSOR_ID
    , S.SEQ
    , S.DATE_INSTALLED
    , S.DATE_REMOVED
    , S.SENSOR_DEPTH_IN FROM (
    SELECT ID
      ,CELL
      ,DESIGN_NUMBER DESIGN
      ,CELL_TYPE
      ,CONSTRUCTION_BEGAN_DATE FROM_DATE
      ,CELL_END_DATE CELL_END_DATE
      ,TO_NUMBER(TO_CHAR(CONSTRUCTION_BEGAN_DATE,'yyyy')) FROM_YEAR
      ,TO_NUMBER(TO_CHAR(CELL_END_DATE,'yyyy')) TO_YEAR 
      FROM (
        SELECT ID
          , CELL
          , CELL_TYPE
          , CONSTRUCTION_BEGAN_DATE
          , CONSTRUCTION_ENDED_DATE
          , CASE WHEN CELL=1 THEN NULL 
              ELSE NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) 
            END CELL_END_DATE
          , DESIGN_NUMBER 
          FROM (
            SELECT ID
              , CELL_NUMBER CELL
              , SUBSTR(CLASS,24) CELL_TYPE
              , (SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=C.ID) CONSTRUCTION_BEGAN_DATE
              , CONSTRUCTION_ENDED_DATE
              , DEMOLISHED_DATE
              , CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1
                    WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2
                    WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3
                    WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4
                    WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5
                    ELSE 1 
               END DESIGN_NUMBER 
              FROM MNR.CELL C
          )
        )
      ) CELLS 
  JOIN MNR.LANE LN ON LN.CELL_ID=CELLS.ID JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID 
  JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID JOIN MNR.MATERIAL M ON LY.MATERIAL_ID=M.ID 
---------------------------------------------------------------
CREATE OR REPLACE VIEW TC_SENSORS AS 
SELECT * FROM MNR.CELL_SENSORS WHERE MODEL='TC'
---------------------------------------------------------------
CREATE OR REPLACE VIEW EMBEDDED_TC_SENSORS AS  
SELECT * FROM MNR.TC_SENSORS TCS
WHERE DATE_INSTALLED > CELL_END_DATE
ORDER BY TCS.CELL,TCS.DESIGN,SEQ
---------------------------------------------------------------
CREATE OR REPLACE VIEW ORIGINAL_TC_SENSORS AS  
SELECT * FROM MNR.TC_SENSORS TCS
WHERE DATE_INSTALLED < CELL_END_DATE
ORDER BY TCS.CELL,TCS.DESIGN,SEQ
---------------------------------------------------------------
SELECT CS.CELL_ID
  , CS.CELL
  , CS.DESIGN
  , CS.CELL_TYPE
  , MIN(FROM_DATE) LAYER_FROM_DATE
  , MAX(CELL_END_DATE) LAYER_TO_DATE
  , MIN(SEQ) FROM_SEQ
  , MAX(SEQ) TO_SEQ
  , MIN(DATE_INSTALLED) SENSOR_INSTALL_DATE
  , COUNT(SEQ) NUM_SENSORS FROM (
SELECT * FROM MNR.ORIGINAL_TC_SENSORS CS
) CS GROUP BY CS.CELL_ID,CS.CELL,CS.DESIGN,CS.CELL_TYPE 
ORDER BY CS.CELL,CS.DESIGN,LAYER_FROM_DATE
---------------------------------------------------------------
-- Computes the median depth of each sensor "location_group"
-- These done using the old SENSOR_LOCATIONS table that had a
-- semi-populated LOCATION_GROUP column. 
SELECT Z.LOCATION_GROUP, MIN(DEPTH_MIN) MIN_DEPTH, MAX(DEPTH_MAX) MAX_DEPTH, MEDIAN(MED) "MEDIAN"
FROM (SELECT Y.LOCATION_GROUP, MIN(Y.DEPTH) DEPTH_MIN, MAX(Y.DEPTH) DEPTH_MAX, MEDIAN(Y.DEPTH) MED 
FROM (
SELECT 
X.CELL
,CASE WHEN X.TYPE='HmaCell' THEN 1 WHEN X.TYPE='PccCell' THEN 2 WHEN X.TYPE='AggCell' THEN 3  WHEN X.TYPE='CompositeCell' THEN 4 END
TYPE
,CASE WHEN X.LOCATION='Mainline' THEN 1 WHEN X.LOCATION='Low Volume Road' THEN 2 WHEN X.LOCATION='Farm Road' THEN 3 WHEN X.LOCATION='MnRoad Parking Lot' THEN 4 WHEN X.LOCATION='MnRoad Sidewalk' THEN 5 WHEN X.LOCATION='Public Road' THEN 6  END
LOCATION
 ,X.SENSOR_IDX
,X.STATION
,X.OFFSET
,X.DEPTH
,X.SEQ
,X.MAT
,X.THICKNESS
,X.LOCATION_GROUP
,X.TREE
 FROM (SELECT  
T.CELL
,T.TYPE
,T.LOCATION
, ROW_NUMBER() OVER (PARTITION BY T.CELL ORDER BY T.STATION,T.OFFSET,T.DEPTH) SENSOR_IDX
,T.STATION
,T.OFFSET
,T.DEPTH
,T.SEQ
,T.MAT
,T.THICKNESS
,T.LOCATION_GROUP
,D.TREE TREE
FROM (
SELECT CS.CELL CELL
, CS.PAVEMENT_TYPE TYPE
, CS.FACILITY LOCATION
, CS.STATION_FT STATION
, CS.OFFSET_FT OFFSET
, CS.DEPTH_FT DEPTH
, CS.SEQ SEQ
, CS.DESCRIPTION MAT
, CS.THICKNESS_IN THICKNESS
, SL.LOCATION_GROUP LOCATION_GROUP
FROM (
SELECT C.CELL_NUMBER CELL 
, SUBSTR(C.CLASS,24) PAVEMENT_TYPE
, F.NAME FACILITY
, SM.MODEL
, S.SEQ
, M.DESCRIPTION
, S.STATION_FT
, S.OFFSET_FT
, S.SENSOR_DEPTH_IN/12 DEPTH_FT
, LY.THICKNESS/25.4 THICKNESS_IN
FROM MNR.CELL C 
JOIN MNR.LANE LN ON LN.CELL_ID=C.ID
JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID
JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID
JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID
JOIN MNR.MATERIAL M ON LY.MATERIAL_ID=M.ID
JOIN MNR.ROAD_SECTION R ON C.ROAD_SECTION_ID=R.ID
JOIN MNR.FACILITY F ON R.FACILITY_ID=F.ID
) CS JOIN MNR.SENSOR_LOCATIONS SL ON SL.CELL=CS.CELL AND SL.MODEL=CS.MODEL AND SL.SEQ = CS.SEQ AND CS.DEPTH_FT=SL.DEPTH_FT
WHERE SL.MODEL='TC'
ORDER BY CELL,SEQ
) T
JOIN 
(
SELECT B.CELL_NUMBER CELL,B.STATION_FT STATION,B.OFFSET_FT OFFSET,B.SEQ_MIN,B.SEQ_MAX,B.NUM_SENSORS
, RANK() OVER (PARTITION BY CELL_NUMBER ORDER BY STATION_FT) TREE
FROM (
SELECT C.CELL_NUMBER
,S.STATION_FT, S.OFFSET_FT, MIN(SEQ) SEQ_MIN, MAX(SEQ) SEQ_MAX, COUNT(*) NUM_SENSORS
FROM MNR.CELL C 
JOIN MNR.LANE LN ON LN.CELL_ID=C.ID
JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID
JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID
JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID
WHERE SM.MODEL='TC'
GROUP BY C.CELL_NUMBER,S.STATION_FT, S.OFFSET_FT
ORDER BY C.CELL_NUMBER,S.STATION_FT, S.OFFSET_FT
) B 
) D
ON D.CELL=T.CELL AND D.STATION=T.STATION AND D.OFFSET=T.OFFSET
) X WHERE 
-- Returns 1,120 of 1,133 TC sensors with a non-null location group (2,202 TC sensors in all)
X.LOCATION_GROUP IS NOT NULL
) Y 
GROUP BY Y.TYPE,Y.LOCATION, Y.LOCATION_GROUP
) Z 
GROUP BY Z.LOCATION_GROUP
ORDER BY Z.LOCATION_GROUP
---------------------------------------
-- -- Results using only TC sensors with non-null LOCATION_GROUP in SENSOR_LOCATIONS
-- DEPTH_GROUP  MIN_DEPTH  MAX_DEPTH  MEDIAN    (in FEET)
-- 1            0.08       0.11       0.09
-- 2            0.17       0.19       0.18
-- 3            0.23       0.35       0.265
-- 4            0.39       0.45       0.425
-- 5            0.47       0.55       0.5125
-- 6            0.56       0.85       0.71
-- 7            0.86       1.25       1
-- 8            1.27       1.65       1.47
-- 9            1.7        2.48       1.99
-- 10           2.5        3.59       2.99
-- 11           3.64       4.59       3.995
-- 12           4.64       5.7        5
-- 13           5.82       8.82       7.98
-- -- Results using all TC sensors with inline LOCATION_GROUP table
-- DEPTH_GROUP  MIN_DEPTH  MAX_DEPTH  MEDIAN    (in FEET)
-- 1            0          0.11       0.08
-- 2            0.115      0.19       0.14
-- 3            0.2        0.35       0.2575
-- 4            0.35417    0.45       0.39375
-- 5            0.458      0.55       0.5
-- 6            0.56       0.85       0.725
-- 7            0.86       1.25       1
-- 8            1.27       1.65       1.485
-- 9            1.66667    2.48       1.995
-- 10           2.495      3.59       3
-- 11           3.64       4.59       4
-- 12           4.64       5.7        5
-- 13           5.82       8.82       7.95
---------------------------------------
-- Computes the median depth of each sensor DEPTH_GROUP aka "location_group"
-- These done using the inline TC_DEPTH_RANGE table
SELECT Z.DEPTH_GROUP, MIN(DEPTH_MIN) MIN_DEPTH, MAX(DEPTH_MAX) MAX_DEPTH, MEDIAN(MED) "MEDIAN"
FROM (SELECT Y.DEPTH_GROUP, MIN(Y.DEPTH) DEPTH_MIN, MAX(Y.DEPTH) DEPTH_MAX, MEDIAN(Y.DEPTH) MED
FROM (
SELECT
CASE WHEN X.TYPE='HmaCell' THEN 1 WHEN X.TYPE='PccCell' THEN 2 WHEN X.TYPE='AggCell' THEN 3  WHEN X.TYPE='CompositeCell' THEN 4 END
TYPE
,CASE WHEN X.LOCATION='Mainline' THEN 1 WHEN X.LOCATION='Low Volume Road' THEN 2 WHEN X.LOCATION='Farm Road' THEN 3 WHEN X.LOCATION='MnRoad Parking Lot' THEN 4 WHEN X.LOCATION='MnRoad Sidewalk' THEN 5 WHEN X.LOCATION='Public Road' THEN 6  END
LOCATION
,X.SENSOR_IDX
,X.DEPTH
,X.DEPTH_GROUP
 FROM (SELECT T.TYPE,T.LOCATION, ROW_NUMBER() OVER (PARTITION BY T.CELL ORDER BY T.STATION,T.OFFSET,T.DEPTH) SENSOR_IDX
,T.DEPTH
,T.DEPTH_GROUP
FROM (
SELECT
C.CELL_NUMBER CELL, S.SEQ, SUBSTR(C.CLASS,24) TYPE, F.NAME LOCATION
, S.STATION_FT STATION, S.OFFSET_FT OFFSET, S.SENSOR_DEPTH_IN/12 DEPTH
, DEPTH_GROUP, DESCR DEPTH_GROUP_DESCR, M.DESCRIPTION MAT, LY.THICKNESS/25.4 THICKNESS
FROM MNR.CELL C
JOIN MNR.LANE LN ON LN.CELL_ID=C.ID
JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID
JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID
JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID
JOIN MNR.MATERIAL M ON LY.MATERIAL_ID=M.ID
JOIN MNR.ROAD_SECTION R ON C.ROAD_SECTION_ID=R.ID
JOIN MNR.FACILITY F ON R.FACILITY_ID=F.ID
INNER JOIN MNR.TC_DEPTH_RANGES R
ON S.SENSOR_DEPTH_IN/12 BETWEEN NVL(R.RNG_START, S.SENSOR_DEPTH_IN/12) AND NVL(R.RNG_STOP, S.SENSOR_DEPTH_IN/12)
WHERE SM.MODEL='TC'
ORDER BY CELL, SEQ
) T
JOIN
(
SELECT B.CELL_NUMBER CELL,B.STATION_FT STATION,B.OFFSET_FT OFFSET,B.SEQ_MIN,B.SEQ_MAX,B.NUM_SENSORS
  ,RANK() OVER (PARTITION BY CELL_NUMBER ORDER BY STATION_FT) TREE FROM (
SELECT C.CELL_NUMBER,S.STATION_FT, S.OFFSET_FT, MIN(SEQ) SEQ_MIN, MAX(SEQ) SEQ_MAX, COUNT(*) NUM_SENSORS
FROM MNR.CELL C
JOIN MNR.LANE LN ON LN.CELL_ID=C.ID
JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID
JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID
JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID
WHERE SM.MODEL='TC'
GROUP BY C.CELL_NUMBER,S.STATION_FT, S.OFFSET_FT
ORDER BY C.CELL_NUMBER,S.STATION_FT, S.OFFSET_FT
) B
) D
ON D.CELL=T.CELL AND D.STATION=T.STATION AND D.OFFSET=T.OFFSET
) X WHERE
X.DEPTH_GROUP IS NOT NULL
) Y
GROUP BY Y.TYPE,Y.LOCATION, Y.DEPTH_GROUP
) Z
GROUP BY Z.DEPTH_GROUP
ORDER BY Z.DEPTH_GROUP
-----------------------------------------
-----------------------------------------
CREATE OR REPLACE VIEW TC_DEPTH_RANGES AS
SELECT
--DISTINCT DEPTH_GROUP, DESCR, R.RNG_START, R.RNG_STOP, COUNT(*) OVER (PARTITION BY DEPTH_GROUP,DESCR) N
DEPTH_GROUP,DESCR,RNG_START,RNG_STOP FROM (
        SELECT 1 DEPTH_GROUP,'0.000 - 0.110' DESCR, 0.0 RNG_START, 0.110 RNG_STOP FROM DUAL
UNION (SELECT  2 DEPTH_GROUP,'0.111 - 0.190' DESCR, 0.111, 0.190 FROM DUAL)
UNION (SELECT  3 DEPTH_GROUP,'0.191 - 0.350' DESCR, 0.191, 0.350 FROM DUAL)
UNION (SELECT  4 DEPTH_GROUP,'0.351 - 0.450' DESCR, 0.351, 0.450 FROM DUAL)
UNION (SELECT  5 DEPTH_GROUP,'0.451 - 0.550' DESCR, 0.451, 0.550 FROM DUAL)
UNION (SELECT  6 DEPTH_GROUP,'0.551 - 0.850' DESCR, 0.551, 0.850 FROM DUAL)
UNION (SELECT  7 DEPTH_GROUP,'0.851 - 1.250' DESCR, 0.851, 1.250 FROM DUAL)
UNION (SELECT  8 DEPTH_GROUP,'1.251 - 1.650' DESCR, 1.251, 1.650 FROM DUAL)
UNION (SELECT  9 DEPTH_GROUP,'1.651 - 2.480' DESCR, 1.651, 2.480 FROM DUAL)
UNION (SELECT 10 DEPTH_GROUP,'2.481 - 3.590' DESCR, 2.481, 3.590 FROM DUAL)
UNION (SELECT 11 DEPTH_GROUP,'3.591 - 4.590' DESCR, 3.591, 4.590 FROM DUAL)
UNION (SELECT 12 DEPTH_GROUP,'4.591 - 5.700' DESCR, 4.591, 5.700 FROM DUAL)
UNION (SELECT 13 DEPTH_GROUP,'5.701+'        DESCR, 5.701, NULL  FROM DUAL)
)
--------------------------------------------
CREATE OR REPLACE VIEW TC_TREE AS
SELECT B.ID,B.CELL_NUMBER CELL,B.STATION_FT STATION,B.OFFSET_FT OFFSET,B.SEQ_MIN,B.SEQ_MAX,B.NUM_SENSORS
, RANK() OVER (PARTITION BY CELL_NUMBER ORDER BY STATION_FT) TREE
FROM (
SELECT C.ID,C.CELL_NUMBER
,S.STATION_FT, S.OFFSET_FT, MIN(SEQ) SEQ_MIN, MAX(SEQ) SEQ_MAX, COUNT(*) NUM_SENSORS
FROM MNR.CELL C
JOIN MNR.LANE LN ON LN.CELL_ID=C.ID
JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID
JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID
JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID
WHERE SM.MODEL='TC'
GROUP BY C.ID,C.CELL_NUMBER,S.STATION_FT, S.OFFSET_FT
ORDER BY C.ID,C.CELL_NUMBER,S.STATION_FT, S.OFFSET_FT
) B
ORDER BY CELL,ID
--------------------------------------------------------------------
-- Returns all 2,255 TC sensors with a DEPTH_GROUP
-- Requires views MNR.TC_TREE and MNR.TC_DEPTH_RANGES
SELECT "cell", TYPE "type", LOCATION "location", SENSOR_IDX "sensor", "station"
,"offset",DEPTH "depth","seq","material","thickness", DEPTH_GROUP "group", "tree"
FROM (
SELECT
X.CELL "cell"
,CASE WHEN X.TYPE='HmaCell' THEN 1 WHEN X.TYPE='PccCell' THEN 2 WHEN X.TYPE='AggCell' THEN 3  WHEN X.TYPE='CompositeCell' THEN 4 END
TYPE
,CASE WHEN X.LOCATION='Mainline' THEN 1 WHEN X.LOCATION='Low Volume Road' THEN 2 WHEN X.LOCATION='Farm Road' THEN 3 WHEN X.LOCATION='MnRoad Parking Lot' THEN 4 WHEN X.LOCATION='MnRoad Sidewalk' THEN 5 WHEN X.LOCATION='Public Road' THEN 6  END
LOCATION
,X.SENSOR_IDX
,X.STATION "station"
,X.OFFSET "offset"
,X.DEPTH
,X.SEQ "seq"
,X.MAT "material"
,X.THICKNESS "thickness"
,X.DEPTH_GROUP
,X.TREE "tree"
 FROM (SELECT
T.CELL
,T.TYPE
,T.LOCATION
,ROW_NUMBER() OVER (PARTITION BY T.CELL ORDER BY T.STATION,T.OFFSET,T.DEPTH) SENSOR_IDX
,T.STATION
,T.OFFSET
,T.DEPTH
,T.SEQ
,T.MAT
,T.THICKNESS
,T.DEPTH_GROUP
,D.TREE TREE
FROM (
SELECT
C.CELL_NUMBER CELL, S.SEQ, SUBSTR(C.CLASS,24) TYPE, F.NAME LOCATION
, S.STATION_FT STATION, S.OFFSET_FT OFFSET, S.SENSOR_DEPTH_IN/12 DEPTH
, DEPTH_GROUP, DESCR DEPTH_GROUP_DESCR, M.DESCRIPTION MAT, LY.THICKNESS/25.4 THICKNESS
FROM MNR.CELL C
JOIN MNR.LANE LN ON LN.CELL_ID=C.ID
JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID
JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID
JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID
JOIN MNR.MATERIAL M ON LY.MATERIAL_ID=M.ID
JOIN MNR.ROAD_SECTION R ON C.ROAD_SECTION_ID=R.ID
JOIN MNR.FACILITY F ON R.FACILITY_ID=F.ID
INNER JOIN MNR.TC_DEPTH_RANGES R
ON S.SENSOR_DEPTH_IN/12 BETWEEN NVL(R.RNG_START, S.SENSOR_DEPTH_IN/12) AND NVL(R.RNG_STOP, S.SENSOR_DEPTH_IN/12)
WHERE SM.MODEL='TC'
ORDER BY CELL, SEQ
) T
JOIN
(
SELECT CELL, STATION, OFFSET, SEQ_MIN, SEQ_MAX, NUM_SENSORS, TREE
FROM MNR.TC_TREE
) D
ON D.CELL=T.CELL AND D.STATION=T.STATION AND D.OFFSET=T.OFFSET
) X
WHERE X.DEPTH_GROUP IS NOT NULL
)
---------------------------------------------------------------------------
-- "new" sensors embedded into previous sensorProps layers
SELECT CS.CELL, CS.DESIGN, MIN(FROM_DATE) LAYER_FROM_DATE, MAX(CELL_END_DATE) LAYER_TO_DATE, MIN(SEQ) FROM_SEQ, MAX(SEQ) TO_SEQ, COUNT(SEQ) NUM_SENSORS FROM (
SELECT CELLS.ID, CELLS.CELL, CELLS.DESIGN, CELLS.FROM_DATE, CELLS.CELL_END_DATE, LN.NAME LANE, M.BASIC_MATERIAL, ROUND((LY.THICKNESS/2.54),2) THICKNESS_IN, SM.MODEL, S.SEQ, S.DATE_INSTALLED, S.DATE_REMOVED,S.SENSOR_DEPTH_IN FROM (
SELECT ID,CELL,DESIGN_NUMBER DESIGN,CONSTRUCTION_BEGAN_DATE FROM_DATE, CELL_END_DATE CELL_END_DATE,TO_NUMBER(TO_CHAR(CONSTRUCTION_BEGAN_DATE,'yyyy')) FROM_YEAR,TO_NUMBER(TO_CHAR(CELL_END_DATE,'yyyy')) TO_YEAR FROM (
SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE, CASE WHEN CELL=1 THEN NULL ELSE NVL(DEMOLISHED_DATE,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) END CELL_END_DATE,DESIGN_NUMBER FROM (SELECT ID,CELL_NUMBER CELL,SUBSTR(CLASS,24) CELL_TYPE,(SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=C.ID) CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,DEMOLISHED_DATE,CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5ELSE 1 END DESIGN_NUMBER FROM MNR.CELL C))) CELLS JOIN MNR.LANE LN ON LN.CELL_ID=CELLS.ID JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID JOIN MNR.MATERIAL M ON LY.MATERIAL_ID=M.ID WHERE LN.NAME NOT LIKE '%Shldr' AND SM.MODEL='TC'
and s.date_installed > CELLS.CELL_END_DATE
) CS GROUP BY CS.CELL,CS.DESIGN ORDER BY CS.CELL,CS.DESIGN,LAYER_FROM_DATE
-----------------------------------------------------------------------
CREATE OR REPLACE VIEW TC_DESIGN AS
SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE
	,CASE WHEN CELL=1 THEN NULL ELSE NVL(DEMOLISHED_DATE
	,LEAD(CONSTRUCTION_BEGAN_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY CONSTRUCTION_BEGAN_DATE)) END CELL_END_DATE,DESIGN_NUMBER DESIGN FROM (
SELECT ID,CELL_NUMBER CELL,SUBSTR(CLASS,24) CELL_TYPE
	,(SELECT FIRST_LAYER_DATE FROM MNR.CELLS WHERE ID=C.ID) CONSTRUCTION_BEGAN_DATE,CONSTRUCTION_ENDED_DATE,DEMOLISHED_DATE
	,CASE WHEN LEAD(ID,1,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 1
		 WHEN LEAD(ID,2,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 2
		 WHEN LEAD(ID,3,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 3
		 WHEN LEAD(ID,4,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 4
		 WHEN LEAD(ID,5,NULL) OVER (PARTITION BY CELL_NUMBER ORDER BY C.CONSTRUCTION_ENDED_DATE DESC) IS NULL THEN 5 ELSE 1 END DESIGN_NUMBER
		 	FROM MNR.CELL C
		 	ORDER BY CELL,DESIGN_NUMBER
)
-----------------------------------------------------
SELECT D.ID,D.CELL,D.CELL_TYPE,D.CONSTRUCTION_BEGAN_DATE FROM_DATE, D.CELL_END_DATE TO_DATE,D.DESIGN
,T.STATION,T.OFFSET,T.SEQ_MIN,T.SEQ_MAX,T.NUM_SENSORS,T.TREE
FROM TC_TREE T JOIN TC_DESIGN D ON T.ID=D.ID
ORDER BY T.CELL,T.ID

SELECT ID,CELL,CELL_TYPE,CONSTRUCTION_BEGAN_DATE,CELL_END_DATE,DESIGN FROM MNR.CELL_DESIGN ORDER BY CELL,DESIGN

SELECT CD.CELL,CD.DESIGN,CD.CELL_TYPE
,MIN(CD.CONSTRUCTION_BEGAN_DATE) CELL_FROM_DATE,NVL(MAX(CD.CELL_END_DATE),SYSDATE) CELL_TO_DATE
,MIN(TO_NUMBER(TO_CHAR(S.DATE_INSTALLED,'yyyy'))) FROM_YEAR,NVL(MIN(TO_NUMBER(TO_CHAR(S.DATE_REMOVED,'yyyy'))),TO_NUMBER(TO_CHAR(SYSDATE,'yyyy'))) TO_YEAR
,MIN(S.SEQ) SEQ_MIN,MAX(S.SEQ) SEQ_MAX,COUNT(*) NUM_SENSORS 
FROM MNR.CELL_DESIGN CD JOIN MNR.LANE LN ON LN.CELL_ID=CD.ID JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID 
WHERE SM.MODEL='TC' GROUP BY CD.CELL,CD.DESIGN,CD.CELL_TYPE ORDER BY CD.CELL,CD.DESIGN


SELECT * FROM (
SELECT 
   CASE WHEN TYPE='HmaCell' THEN 1 
    WHEN TYPE='PccCell' THEN 2 
    WHEN TYPE='AggCell' THEN 3  
    WHEN TYPE='CompositeCell' THEN 4 
   END PAVEMENT_TYPE
  ,CASE WHEN LOCATION='Mainline' THEN 1 
    WHEN LOCATION='Low Volume Road' THEN 2 
    WHEN LOCATION='Farm Road' THEN 3 
    When Location='MnRoad Parking Lot' THEN 4 
    WHEN LOCATION='MnRoad Sidewalk' THEN 5 
    WHEN LOCATION='Public Road' THEN 6  
   END FACILITY
  ,X.CELL
  ,X.DESIGN
  ,X.FROM_DATE CELL_FROM_DATE
  ,X.DATE_INSTALLED SENSOR_INSTALLED_DATE
  ,X.DATE_REMOVED SENSOR_REMOVED_DATE
  ,CASE
    WHEN X.TO_DATE < X.FROM_DATE OR X.TO_DATE IS NULL THEN SYSDATE
    ELSE X.TO_DATE 
   END CELL_TO_DATE
  ,X.SEQ
  ,CASE
   WHEN X.DATE_REMOVED IS NULL THEN 'ACTIVE'
   WHEN X.TO_DATE IS NOT NULL AND X.DATE_REMOVED > X.TO_DATE THEN 'REMOVED B4 CELL'
   WHEN X.TO_DATE IS NOT NULL AND X.DATE_REMOVED <= X.TO_DATE THEN 'REMOVED'
   WHEN X.DATE_REMOVED IS NULL AND X.TO_DATE IS NOT NULL THEN 'DISCONNECTED'
   ELSE '??'
   END SENSOR_STATUS
  ,X.DEPTH
  ,X.DEPTH_GROUP
  ,X.STATION
  ,X.OFFSET
  ,X.MAT
  ,X.THICKNESS
  ,X.SENSOR_IDX
  FROM ( -- X
    SELECT UNIQUE 
        T.DATE_INSTALLED
       ,T.DATE_REMOVED
       ,NVL(T.CELL_END_DATE,SYSDATE) TO_DATE
       , CASE
         WHEN T.CELL_END_DATE IS NOT NULL AND T.DATE_INSTALLED > T.CELL_END_DATE
         THEN T.CELL_END_DATE+1
         ELSE T.FIRST_LAYER_DATE 
         END FROM_DATE
		,T.CELL
		,T.DESIGN
		,T.TYPE
		,T.LOCATION
		,ROW_NUMBER() OVER (PARTITION BY T.CELL ORDER BY T.STATION,T.OFFSET,T.DEPTH) SENSOR_IDX
		,T.STATION
		,T.OFFSET
		,T.DEPTH
		,T.SEQ
		,T.MAT
		,T.THICKNESS
		,T.DEPTH_GROUP
	FROM ( -- T
		SELECT C.CELL_NUMBER CELL
		  ,CD.DESIGN
			, S.SEQ
			, SUBSTR(C.CLASS,24) TYPE
			, F.NAME LOCATION
			, S.STATION_FT STATION
			, S.OFFSET_FT OFFSET
			, ROUND((S.SENSOR_DEPTH_IN/12),4) DEPTH
			, DEPTH_GROUP, DESCR DEPTH_GROUP_DESCR
			, M.DESCRIPTION MAT
			, LY.THICKNESS/25.4 THICKNESS 
		  ,CD.CONSTRUCTION_BEGAN_DATE FIRST_LAYER_DATE
		  ,CD.CELL_END_DATE 
		  ,S.DATE_INSTALLED
		  ,S.DATE_REMOVED
		FROM MNR.CELL C JOIN MNR.LANE LN ON LN.CELL_ID=C.ID 
		JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID 
		JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID 
		JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID 
		JOIN MNR.MATERIAL M ON LY.MATERIAL_ID=M.ID 
		JOIN MNR.ROAD_SECTION R ON C.ROAD_SECTION_ID=R.ID 
		JOIN MNR.FACILITY F ON R.FACILITY_ID=F.ID 
		JOIN MNR.CELL_DESIGN CD ON CD.ID=C.ID
		INNER JOIN MNR.DEPTH_RANGE R ON ROUND((S.SENSOR_DEPTH_IN/12),4) BETWEEN NVL(R.RNG_START, ROUND((S.SENSOR_DEPTH_IN/12),4)) AND NVL(R.RNG_STOP, ROUND((S.SENSOR_DEPTH_IN/12),4)) WHERE SM.MODEL='TC' ORDER BY CELL, SEQ ) T 
		JOIN ( -- D 258 rows
			SELECT C.CELL_NUMBER CELL
				,S.STATION_FT STATION
				,S.OFFSET_FT OFFSET
				,MIN(SEQ) SEQ_MIN
				,MAX(SEQ) SEQ_MAX
				,COUNT(*) NUM_SENSORS 
			FROM MNR.CELL C 
			JOIN MNR.LANE LN ON LN.CELL_ID=C.ID 
			JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID 
			JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID 
			JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID 
			WHERE SM.MODEL='TC' 
			GROUP BY C.CELL_NUMBER
				,S.STATION_FT
				,S.OFFSET_FT 
			ORDER BY C.CELL_NUMBER
				,S.STATION_FT
				,S.OFFSET_FT
			) D ON D.CELL=T.CELL AND D.STATION=T.STATION AND D.OFFSET=T.OFFSET
		) X WHERE X.DEPTH_GROUP IS NOT NULL
) WHERE CELL=? ORDER BY CELL, SEQ

CREATE OR REPLACE VIEW CELL_SUMMARY AS
SELECT
ID ,
CELL,
FIRST_LAYER_DATE,
LAST_LAYER_DATE,
CONSTRUCTION_ENDED_DATE,
CELL_END_DATE TO_DATE,
TYPE,
DESIGN_NUMBER
FROM
(
   SELECT
   ID ,
   CELL,
   CELL_TYPE TYPE,
   FIRST_LAYER_DATE,
   LAST_LAYER_DATE,
   CONSTRUCTION_ENDED_DATE,
   NVL(DEMOLISHED_DATE,LEAD(FIRST_LAYER_DATE-1,1,NULL) OVER (PARTITION BY CELL ORDER BY FIRST_LAYER_DATE)) CELL_END_DATE,
   DESIGN_NUMBER
   FROM
   (
      SELECT
      ID ,
      CELL_NUMBER CELL ,
      SUBSTR(CLASS,24) CELL_TYPE ,
      (SELECT MIN(SL.CONSTRUCT_START_DATE) FROM MNR.CELL SC JOIN MNR.LANE SLN ON SLN.CELL_ID=SC.ID JOIN MNR.LAYER SL ON SL.LANE_ID=SLN.ID WHERE SC.ID=C.ID) FIRST_LAYER_DATE ,
      (SELECT MAX(SL.CONSTRUCT_START_DATE) FROM MNR.CELL SC JOIN MNR.LANE SLN ON SLN.CELL_ID=SC.ID JOIN MNR.LAYER SL ON SL.LANE_ID=SLN.ID WHERE SC.ID=C.ID) LAST_LAYER_DATE ,
      CONSTRUCTION_ENDED_DATE ,
      DEMOLISHED_DATE ,
      CASE WHEN LEAD
      (
         ID,1,NULL
      )
      OVER
      (
         PARTITION BY CELL_NUMBER
         ORDER BY C.CONSTRUCTION_ENDED_DATE DESC
      )
      IS NULL THEN 1 WHEN LEAD
      (
         ID,2,NULL
      )
      OVER
      (
         PARTITION BY CELL_NUMBER
         ORDER BY C.CONSTRUCTION_ENDED_DATE DESC
      )
      IS NULL THEN 2 WHEN LEAD
      (
         ID,3,NULL
      )
      OVER
      (
         PARTITION BY CELL_NUMBER
         ORDER BY C.CONSTRUCTION_ENDED_DATE DESC
      )
      IS NULL THEN 3 WHEN LEAD
      (
         ID,4,NULL
      )
      OVER
      (
         PARTITION BY CELL_NUMBER
         ORDER BY C.CONSTRUCTION_ENDED_DATE DESC
      )
      IS NULL THEN 4 WHEN LEAD
      (
         ID,5,NULL
      )
      OVER
      (
         PARTITION BY CELL_NUMBER
         ORDER BY C.CONSTRUCTION_ENDED_DATE DESC
      )
      IS NULL THEN 5 ELSE 1 END DESIGN_NUMBER
      FROM MNR.CELL C
   )
)

CREATE OR REPLACE VIEW SENSOR_SUM_BY_SEQ AS
SELECT
C.CELL_NUMBER CELL
,SM.MODEL
,MIN(SEQ) SEQ_MIN
,MAX(SEQ) SEQ_MAX
,S.STATION_FT STATION
,S.OFFSET_FT OFFSET
,COUNT(*) NUM_SENSORS
FROM MNR.CELL C JOIN MNR.LANE LN ON LN.CELL_ID=C.ID JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID
GROUP BY C.CELL_NUMBER,SM.MODEL,S.STATION_FT, S.OFFSET_FT
ORDER BY C.CELL_NUMBER,MIN(SEQ)
;

CREATE OR REPLACE VIEW CELL_SENSOR_PROPS AS
    SELECT
       T.CELL, T.TYPE, T.LOCATION
       , CASE
         WHEN T.CELL_END_DATE IS NOT NULL AND T.DATE_INSTALLED > T.CELL_END_DATE
           THEN T.CELL_END_DATE+1
         ELSE T.FIRST_LAYER_DATE
         END CELL_FROM_DATE
       , NVL(T.CELL_END_DATE,SYSDATE) CELL_TO_DATE
       , T.MAT, T.THICKNESS
       , T.MODEL
       , T.SEQ
       , T.DATE_INSTALLED, T.DATE_REMOVED
       , ROW_NUMBER() OVER (PARTITION BY T.CELL ORDER BY T.STATION,T.OFFSET,T.DEPTH) SENSOR_IDX
       , T.STATION, T.OFFSET, T.DEPTH
       , T.DEPTH_GROUP
    FROM ( -- SUBSELECT T
        SELECT C.CELL_NUMBER CELL, S.SEQ, SUBSTR(C.CLASS,24) TYPE, F.NAME LOCATION
          , DEPTH_GROUP, DESCR DEPTH_GROUP_DESCR
          , M.DESCRIPTION MAT
          , LY.THICKNESS/25.4 THICKNESS
          , CD.CONSTRUCTION_ENDED_DATE FIRST_LAYER_DATE, CD.TO_DATE CELL_END_DATE
          , SM.MODEL
          , ROUND((S.SENSOR_DEPTH_IN/12),4) DEPTH
          , S.DATE_INSTALLED, S.DATE_REMOVED
          , S.STATION_FT STATION, S.OFFSET_FT OFFSET
        FROM MNR.CELL C JOIN MNR.LANE LN ON LN.CELL_ID=C.ID
        JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID
        JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID
        JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID
        JOIN MNR.MATERIAL M ON LY.MATERIAL_ID=M.ID
        JOIN MNR.ROAD_SECTION R ON C.ROAD_SECTION_ID=R.ID
        JOIN MNR.FACILITY F ON R.FACILITY_ID=F.ID
        JOIN MNR.CELL_SUMMARY CD ON CD.ID=C.ID
        JOIN MNR.DEPTH_RANGE R ON
		  ROUND((S.SENSOR_DEPTH_IN/12),4)
		  BETWEEN NVL(R.RNG_START, ROUND((S.SENSOR_DEPTH_IN/12),4))
		      AND NVL(R.RNG_STOP, ROUND((S.SENSOR_DEPTH_IN/12),4))
	) T
    JOIN MNR.SENSOR_SUM_BY_SEQ D ON D.CELL=T.CELL AND D.STATION=T.STATION AND D.OFFSET=T.OFFSET AND D.MODEL=T.MODEL

    
	SELECT
	   T.CELL, T.TYPE, T.LOCATION 
	   , CASE WHEN T.CELL_END_DATE IS NOT NULL
	       AND T.DATE_INSTALLED > T.CELL_END_DATE THEN T.CELL_END_DATE+1 ELSE T.FIRST_LAYER_DATE 
	     END CELL_FROM_DATE
	  ,NVL(T.CELL_END_DATE,SYSDATE) CELL_TO_DATE
	  ,T.MAT
	  ,T.THICKNESS
	  ,T.MODEL
	  ,T.SENSOR_ID
	  ,T.SEQ
	  ,T.DATE_INSTALLED
	  ,T.DATE_REMOVED
	  ,ROW_NUMBER() OVER (PARTITION BY T.CELL ORDER BY T.STATION,T.OFFSET,T.DEPTH) SENSOR_IDX
	  ,T.STATION
	  ,T.OFFSET
	  ,T.DEPTH
	  ,T.DEPTH_GROUP
	  FROM
	  ( -- Subselect T
	   SELECT
	   C.CELL_NUMBER CELL
	   ,SUBSTR(C.CLASS,24) TYPE
	   ,F.NAME LOCATION
	   ,DEPTH_GROUP
	   ,DESCR DEPTH_GROUP_DESCR
	   ,M.DESCRIPTION MAT
	   ,LY.THICKNESS/25.4 THICKNESS
	   ,CD.CONSTRUCTION_ENDED_DATE FIRST_LAYER_DATE
	   ,CD.TO_DATE CELL_END_DATE
	   ,SM.MODEL
	   ,S.ID SENSOR_ID
	   ,S.SEQ
	   ,ROUND((S.SENSOR_DEPTH_IN/12),4) DEPTH
	   ,S.DATE_INSTALLED
	   ,S.DATE_REMOVED
	   ,S.STATION_FT STATION
	   ,S.OFFSET_FT OFFSET
	   FROM MNR.CELL C 
	     JOIN MNR.LANE LN ON LN.CELL_ID=C.ID 
	     JOIN MNR.LAYER LY ON LY.LANE_ID=LN.ID 
	     JOIN MNR.SENSOR S ON S.LAYER_ID=LY.ID 
	     JOIN MNR.SENSOR_MODEL SM ON S.SENSOR_MODEL_ID=SM.ID 
	     JOIN MNR.MATERIAL M ON LY.MATERIAL_ID=M.ID 
	     JOIN MNR.ROAD_SECTION R ON C.ROAD_SECTION_ID=R.ID 
	     JOIN MNR.FACILITY F ON R.FACILITY_ID=F.ID 
	     JOIN MNR.CELL_SUMMARY CD ON CD.ID=C.ID 
	     JOIN MNR.DEPTH_RANGE R ON  ROUND((S.SENSOR_DEPTH_IN/12),4)
	       BETWEEN NVL(R.RNG_START, ROUND((S.SENSOR_DEPTH_IN/12),4))
	           AND NVL(R.RNG_STOP,  ROUND((S.SENSOR_DEPTH_IN/12),4))
	  )
	  T JOIN MNR.SENSOR_SUM_BY_SEQ D ON D.CELL=T.CELL
	  AND D.STATION=T.STATION
	  AND D.OFFSET=T.OFFSET
	  AND D.MODEL=T.MODEL
	
